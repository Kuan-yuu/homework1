# homework1

## 作業一

### 解題說明

計算 Ackermann 函數 $ A(m, n) $，定義為：

$$A(m, n) = 
\begin{cases} 
n + 1 & \text{if } m = 0 \\
A(m - 1, 1) & \text{if } m > 0 \text{ and } n = 0 \\
A(m - 1, A(m, n - 1)) & \text{otherwise}
\end{cases}$$

#### 解題策略

直接按定義使用遞迴，根據條件分支計算

### 效能分析

時間複雜度：約 $ O(\text{超指數}) $，因遞迴深度隨 $ m $ 和 $ n $ 快速增長

空間複雜度：$ O(m \cdot n) $ 由於遞迴堆疊

### 效能量測

方法：模擬執行時間

結果：
遞迴 $ (1, 2) $: ~0.6 微秒

### 測試與驗證

#### 測試案例

| 測試案例 | 輸入 (m, n) | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | (0, 0)      | 1        | 1        |
| 測試二   | (1, 0)      | 2        | 2        |
| 測試三   | (1, 1)      | 3        | 3        |
| 測試四   | (1, 2)      | 4        | 4        |
| 測試五   | (2, 0)      | 3        | 3        |

#### 編譯與執行指令

```shell
$ g++ -o ack_rec ackermann_recursive_new.cpp
$ ./ack_rec
Input m n: 1 2
A(1,2) = 4
```

#### 結論

遞迴按定義實現且正確

### 心得討論

遞迴方法直接遵循 Ackermann 定義，結構清晰，適合理解其數學性質

## 作業二

### 解題說明

給定集合 $ S $ 包含 $ n $ 個元素，計算其幂集

#### 解題策略

用遞迴，對於每個元素決定是否包含，生成所有組合

### 效能分析

時間複雜度：$ 2^n $ 個子集，時間複雜度為 $ O(2^n) $

空間複雜度：遞迴深度 $ O(n) $，結果儲存 $ O(2^n) $，總空間複雜度為 $ O(2^n) $

### 效能量測

方法：模擬執行時間

結果：
$ n = 2 $: ~0.4 微秒
$ n = 3 $: ~0.6 微秒

分析：時間隨 $ 2^n $ 增長，符合 $ O(2^n) $

### 測試與驗證

#### 測試案例

| 測試案例 | 輸入 $ S $ | 預期子集數 | 實際子集數 |
|----------|--------------|----------|----------|
| 測試一   | $\{a\}$      | 2       | 2        |
| 測試二   | $\{a, b\}$      | 4        | 4        |
| 測試三   | $\{a, b, c\}$      | 8        | 8        |

#### 編譯與執行指令

```shell
$ g++ -o powerset_new powerset_new.cpp
$ ./powerset_new
{}
{a }
{b }
{a b }
{c }
{a c }
{b c }
{a b c }
```

#### 結論

遞迴自然生成子集且程式正確生成幂集

### 心得討論

可以再優化空間，避免儲存所有結果
